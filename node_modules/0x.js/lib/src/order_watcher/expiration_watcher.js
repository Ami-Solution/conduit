"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var bintrees_1 = require("bintrees");
var _ = require("lodash");
var types_1 = require("../types");
var interval_utils_1 = require("../utils/interval_utils");
var utils_1 = require("../utils/utils");
var DEFAULT_EXPIRATION_MARGIN_MS = 0;
var DEFAULT_ORDER_EXPIRATION_CHECKING_INTERVAL_MS = 50;
/**
 * This class includes the functionality to detect expired orders.
 * It stores them in a min heap by expiration time and checks for expired ones every `orderExpirationCheckingIntervalMs`
 */
var ExpirationWatcher = /** @class */ (function () {
    function ExpirationWatcher(expirationMarginIfExistsMs, orderExpirationCheckingIntervalIfExistsMs) {
        var _this = this;
        this.expiration = {};
        this.expirationMarginMs = expirationMarginIfExistsMs ||
            DEFAULT_EXPIRATION_MARGIN_MS;
        this.orderExpirationCheckingIntervalMs = expirationMarginIfExistsMs ||
            DEFAULT_ORDER_EXPIRATION_CHECKING_INTERVAL_MS;
        var scoreFunction = function (orderHash) { return _this.expiration[orderHash].toNumber(); };
        var comparator = function (lhs, rhs) { return scoreFunction(lhs) - scoreFunction(rhs); };
        this.orderHashByExpirationRBTree = new bintrees_1.RBTree(comparator);
    }
    ExpirationWatcher.prototype.subscribe = function (callback) {
        if (!_.isUndefined(this.orderExpirationCheckingIntervalIdIfExists)) {
            throw new Error(types_1.ZeroExError.SubscriptionAlreadyPresent);
        }
        this.orderExpirationCheckingIntervalIdIfExists = interval_utils_1.intervalUtils.setAsyncExcludingInterval(this.pruneExpiredOrders.bind(this, callback), this.orderExpirationCheckingIntervalMs);
    };
    ExpirationWatcher.prototype.unsubscribe = function () {
        if (_.isUndefined(this.orderExpirationCheckingIntervalIdIfExists)) {
            throw new Error(types_1.ZeroExError.SubscriptionNotFound);
        }
        interval_utils_1.intervalUtils.clearAsyncExcludingInterval(this.orderExpirationCheckingIntervalIdIfExists);
        delete this.orderExpirationCheckingIntervalIdIfExists;
    };
    ExpirationWatcher.prototype.addOrder = function (orderHash, expirationUnixTimestampMs) {
        this.expiration[orderHash] = expirationUnixTimestampMs;
        this.orderHashByExpirationRBTree.insert(orderHash);
    };
    ExpirationWatcher.prototype.removeOrder = function (orderHash) {
        this.orderHashByExpirationRBTree.remove(orderHash);
        delete this.expiration[orderHash];
    };
    ExpirationWatcher.prototype.pruneExpiredOrders = function (callback) {
        var currentUnixTimestampMs = utils_1.utils.getCurrentUnixTimestampMs();
        while (true) {
            var hasTrakedOrders = this.orderHashByExpirationRBTree.size === 0;
            if (hasTrakedOrders) {
                break;
            }
            var nextOrderHashToExpire = this.orderHashByExpirationRBTree.min();
            var hasNoExpiredOrders = this.expiration[nextOrderHashToExpire].greaterThan(currentUnixTimestampMs.plus(this.expirationMarginMs));
            var isSubscriptionActive = _.isUndefined(this.orderExpirationCheckingIntervalIdIfExists);
            if (hasNoExpiredOrders || isSubscriptionActive) {
                break;
            }
            var orderHash = this.orderHashByExpirationRBTree.min();
            this.orderHashByExpirationRBTree.remove(orderHash);
            delete this.expiration[orderHash];
            callback(orderHash);
        }
    };
    return ExpirationWatcher;
}());
exports.ExpirationWatcher = ExpirationWatcher;
//# sourceMappingURL=expiration_watcher.js.map