import BigNumber from 'bignumber.js';
import { ExchangeWrapper } from '../contract_wrappers/exchange_wrapper';
import { TokenWrapper } from '../contract_wrappers/token_wrapper';
import { Order, SignedOrder } from '../types';
import { ExchangeTransferSimulator } from './exchange_transfer_simulator';
export declare class OrderValidationUtils {
    private tokenWrapper;
    private exchangeWrapper;
    static validateCancelOrderThrowIfInvalid(order: Order, cancelTakerTokenAmount: BigNumber, unavailableTakerTokenAmount: BigNumber): void;
    static validateFillOrderBalancesAllowancesThrowIfInvalidAsync(exchangeTradeEmulator: ExchangeTransferSimulator, signedOrder: SignedOrder, fillTakerTokenAmount: BigNumber, senderAddress: string, zrxTokenAddress: string): Promise<void>;
    private static validateRemainingFillAmountNotZeroOrThrow(takerTokenAmount, unavailableTakerTokenAmount);
    private static validateOrderNotExpiredOrThrow(expirationUnixTimestampSec);
    private static getPartialAmount(numerator, denominator, target);
    constructor(tokenWrapper: TokenWrapper, exchangeWrapper: ExchangeWrapper);
    validateOrderFillableOrThrowAsync(exchangeTradeEmulator: ExchangeTransferSimulator, signedOrder: SignedOrder, zrxTokenAddress: string, expectedFillTakerTokenAmount?: BigNumber): Promise<void>;
    validateFillOrderThrowIfInvalidAsync(exchangeTradeEmulator: ExchangeTransferSimulator, signedOrder: SignedOrder, fillTakerTokenAmount: BigNumber, takerAddress: string, zrxTokenAddress: string): Promise<BigNumber>;
    validateFillOrKillOrderThrowIfInvalidAsync(exchangeTradeEmulator: ExchangeTransferSimulator, signedOrder: SignedOrder, fillTakerTokenAmount: BigNumber, takerAddress: string, zrxTokenAddress: string): Promise<void>;
}
